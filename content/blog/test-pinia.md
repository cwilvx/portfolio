---
title: Testing Pinia stores in Vue 3 using Vitest
date: 2023-10-13
type: blog
_draft: false
---

In this article, I will show you how to write integration tests for a Vue 3 app that uses Pinia for state management.

To do this, we will create a todo list app to demonstrate how we can test our stores using Vitest.

## Create a todo list app

Run the following command in a terminal to download the vue typescript starter.

```sh
yarn create vite todolist --template vue-ts
```

Change into the project directory and install dependencies:

```sh
cd todolist

yarn install

yarn add pinia
```

Open `main.ts` and register pinia.

```js
import { createApp } from "vue";
import { createPinia } from "pinia";

import "./style.css";
import App from "./App.vue";

const app = createApp(App);
const pinia = createPinia();

app.use(pinia);

app.mount("#app");
```

Create a new pinia store at `src/stores/todo.ts` and add the following code:

```ts
import { nanoid } from "nanoid";
import { defineStore } from "pinia";
import { ref, computed, type Ref } from "vue";

type Todo = { id: string; text: string; isCompleted: boolean };

export default defineStore("todolist", () => {
  const todos: Ref<Todo[]> = ref([]);

  const completedTodos = computed(() =>
    todos.value.filter((todo) => todo.isCompleted === true)
  );
  const incompleteTodos = computed(() =>
    todos.value.filter((todo) => todo.isCompleted !== true)
  );

  const lsKey = "_v_todos";

  function initFromLocalStorage() {
    const lstodos = localStorage.getItem(lsKey);

    if (lstodos === null) {
      todos.value = [];
    } else {
      try {
        todos.value = JSON.parse(lstodos);
      } catch (e) {
        todos.value = [];
      }
    }

    updateLocalStorage();
  }

  function updateLocalStorage() {
    localStorage.setItem(lsKey, JSON.stringify(todos.value));
  }

  function addTodo(text: string) {
    todos.value = [
      ...todos.value,
      {
        id: nanoid(),
        isCompleted: false,
        text,
      },
    ];
    updateLocalStorage();
  }

  function removeTodo(id: string) {
    todos.value = todos.value.filter((todo) => todo.id !== id);
    updateLocalStorage();
  }

  function toggleTodo(id: string) {
    todos.value.forEach((todo) => {
      if (todo.id === id) todo.isCompleted = !todo.isCompleted;
    });
    updateLocalStorage();
  }

  function clearCompletedTodos() {
    todos.value = todos.value.filter((todo) => todo.isCompleted === false);
  }

  return {
    todos,
    completedTodos,
    incompleteTodos,
    addTodo,
    removeTodo,
    toggleTodo,
    initFromLocalStorage,
    updateLocalStorage,
    clearCompletedTodos,
  };
});
```

The store manages a list of todos. Each todo is an object which has an `id`, `text`, and `isCompleted` properties.

The `lsKey` is a constant string that is used as a key to store and retrieve todos from the local storage.

The `initFromLocalStorage` function retrieves the todos from the local storage. If the retrieved value is null or not a valid JSON, it sets todos to an empty array. After initializing todos, it calls `updateLocalStorage` to sync the current state of todos with the local storage.

The `updateLocalStorage` function saves the current state of todos to the local storage. It converts todos to a JSON string before saving.

The `addTodo` function adds a new todo to the todos array. It creates a new todo object with a unique `id` generated by `nanoid`, `isCompleted` set to false, and `text` set to the input argument. After adding a new todo, it calls `updateLocalStorage` to sync the current state of todos with the local storage.

The `removeTodo` function removes a todo from the `todos` array based on the input `id`. After removing a todo, it calls `updateLocalStorage` to sync the current state of todos with the local storage.

The `toggleTodo` function toggles the `isCompleted` property of a todo based on the input `id`. After toggling a todo, it calls `updateLocalStorage` to sync the current state of todos with the local storage.

The `clearCompletedTodos` function removes all completed todos from the todos array.

With the store in place, we can now put together the UI. Open `App.vue` and add the following code:

```vue
<template>
  <main>
    <h1>Todos</h1>

    <button @click="todoStore.clearCompletedTodos()" class="clear">
      Clear completed todos
    </button>

    <div class="prog">
      <progress
        :max="todoStore.todos.length"
        :value="todoStore.completedTodos.length"
      ></progress>
      <p>
        <b>{{ todoStore.completedTodos.length }}</b> out of
        <b>{{ todoStore.todos.length }}</b> completed
      </p>
    </div>
    <ul class="todos" v-for="todo in todoStore.todos" v-bind:key="todo.id">
      <li class="todo">
        <input
          type="checkbox"
          name="isCompleted"
          :id="todo.id"
          :checked="todo.isCompleted"
          @change="todoStore.toggleTodo(todo.id)"
        />
        <label
          :for="todo.id"
          :class="todo.isCompleted ? 'completed' : 'incomplete'"
          >{{ todo.text }}</label
        >
      </li>
    </ul>

    <form @submit.prevent="addTodo" class="addForm">
      <label for="add">Add todo</label>
      <div class="sl">
        <input type="text" name="add" id="add" v-model="currentTodoInp" />
        <button type="submit">Add</button>
      </div>
    </form>
  </main>
</template>

<script setup lang="ts">
import { ref } from "vue";
import useTodoStore from "./stores/todo";

const todoStore = useTodoStore();
todoStore.initFromLocalStorage();

let currentTodoInp = ref("");

function addTodo() {
  const text = currentTodoInp.value;
  currentTodoInp.value = "";

  if (text.trim() !== "") {
    todoStore.addTodo(text);
  }
}
</script>
```

The code adds a button to clear completed todos, a progress bar to show the number of completed todos, a list of todos, and a form to add a new one.

When the component is mounted, we call `todoStore.initFromLocalStorage` to initialize the todos from the local storage.

The `currentTodoInp` is a reactive reference (`Ref`) to a string. It's used to store the current value of the input field in the form.

The `addTodo` function is called when the form is submitted. It gets the current value of `currentTodoInp`, resets `currentTodoInp` to an empty string, and then calls `todoStore.addTodo` to add a new todo if the text is not empty.

We can add some CSS to it to make it look just a bit better:

```vue
<style scoped>
progress {
  width: 100%;
}

ul {
  list-style: none;
  padding: 0;
}

li {
  display: flex;
  align-items: center;
}

label.completed {
  color: #b8b6ce;
  text-decoration: line-through;
}

.sl {
  display: flex;
}
.sl > input {
  border: 1px solid #3f3f3f;
  border-radius: 0.5rem;
  margin-right: 0.5rem;
}

.sl > button {
  background-color: #2f73f0;
}
</style>
```

## Installing Vitest

We'll use vitest to run our tests. We will also need Vue Test Utils, which is a library the provides useful functions for testing Vue components.

Install them using the following command:

```sh
yarn add --dev vitest @vue/test-utils
```

## Setting up Vitest

Vitest uses Vite under the hood and uses the same configuration file. This is great because it means you don't have to duplicate your configuration between the two tools.

As we are working on a Vue 3 app, we'll need to ensure that the `@vitejs/plugin-vue` plugin is installed and used within our `vite.config.ts` configuration.

Add a `vite.config.ts` file to the root of your project.

```js
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
});
```

## Configuring Vitest

Next, we'll configure Vitest. This is done by creating a `vitest.config.ts` file at the root of your project.

```ts
import { defineConfig, mergeConfig } from "vitest/config";
import viteConfig from "./vite.config";

export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      environment: "jsdom",
      // Use jsdom environment, which is needed for
      // testing components that use the DOM
    },
  })
);
```

By default, Vitest looks for any files that match this pattern `['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}']`.

This means that we can place our tests anywhere in our project as long as they match this pattern.

I like to put my tests in a separate folder, so I'll place them within a `src/tests` folder.

We'll also add the following script to our `package.json` file.

```json
{
  "scripts": {
    "test": "vitest"
  }
}
```

## Writing the first Test

When writing integration tests for Single Page Applications, I like to use the root component as the starting point.

I do this because the root component will include all other components, so testing this component will make sure that all components work together as expected.

Since this test doesn't have to know about the implementation details of any subcomponents (also known as "black box testing") it will be robust and have a good chance of catching real bugs.

We'll create a `tests` folder inside our `src` dir and add a `App.test.ts` file.

```ts
describe("AppView", () => {
  test("should be able to add and complete todos", async () => {
    const wrapper = mount(HomeView, {
      global: {
        plugins: [createPinia()],
      },
    });

    // Find the todo input
    const todoInput = wrapper.find("[data-testid='todo-input']");

    // Find the add todo button
    const addTodoButton = wrapper.find("[data-testid='todo-add-button']");

    // Create the two todos
    await todoInput.setValue("First Todo");
    await addTodoButton.trigger("click");
    await todoInput.setValue("Second Todo");
    await addTodoButton.trigger("click");

    // Find all open todo items
    const todos = wrapper.findAll("[data-testid='todo-item']");

    // Check if there are two open todos
    expect(todos.length).toBe(2);

    // Check the first todo
    await todos.at(0)?.setValue("checked");

    // Find all done todo items
    const doneTodos = wrapper.findAll("[data-testid='todo-item-done']");

    // Check if there is one done todo
    expect(doneTodos.length).toBe(1); // Check if there is one done todo

    // Should still have one open todo
    expect(wrapper.findAll("[data-testid='todo-item']").length).toBe(1);
  });
});
```

You can now run the test using:

```sh
yarn test
```

A few things worth noting here:

- We use the `mount` function from `@vue/test-utils` to mount the component.

- We use the `createPinia` function from `pinia` to create a new pinia instance. We- **don't** mock our store, because we want to test the real store.
- We use the `data-testid` attribute to find elements within our component. This- makes our tests more robust. Kent C. Dodds wrote about this in his blog post titled "[Making your UI tests resilient to change](https://kentcdodds.com/blog/making-your-ui-tests-resilient-to-change)" which I highly recommend you read.
- We don't try to test the implementation details of our components. We test the- component like a real user would.

That's it for now!

Happy Testing!
